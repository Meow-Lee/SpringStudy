스프링 주요 기능
- IoC(제어의 역전)은 POJO(오래된 방식의 단순 자바 객체)를 구성하고 관리
- 스프링 프레임워크의 가장 중요한 의의가 POJO로 자바 애플리케이션을 개발하는 것
- 스프링 주요 기능은 대부분 IoC 컨테이너 안에서 POJO를 구성하고 관리하는 일과 연관되어 있음
- Bean = POJO 인스턴스 모두 자바 클래스로 생성한 객체 인스턴스를 가리킴
- Component = POJO 클래스 모두 객체 인스턴스를 생성하는데 필요한 자바 클래스를 의미
- @Configuration -> 해당 클래스가 구성 클래스임을 스프링에 알림
- 스프링은 @Configuration을 보면 우선 해당 클래스 안에서 @Bean을 붙인 자바 메서드를 찾음
- 따로 이름을 명시하지 않으면 메서드의 이름과 동일한 이름의 빈 생성
- Annotation을 붙인 자바 클래스를 스캐닝하려면, 우선 IoC 컨테이너를 인스턴스화 해야함
- 그래야 @Configuration, @Bean을 발견하고 나중에 IoC 컨테이너에서 빈 인스턴스를 가져올 수 있기 때문
- 스프링은 기본 구현체인 BeanFactory, 고급 구현체인 ApplicationContext 등 두가지 IoC 컨테이너 제공
- 리소스에 제약을 받는 것이 아니라면, 가급적 ApplicationContext 사용 권장
- 둘 모두 인터페이스이고, ApplicationContext가 BeanFactory의 하위 인터페이스로 호환이 보장
- ApplicationContext의 구현체로 AnnotationConfigApplicationContext 사용 권장
- 따라서 ApplicationContext ac = new AnnotationConfigApplicationContext(~.class)와 같은 형식으로 IoC 컨테이너를 인스턴스화 한 뒤, 객체 레퍼런스(ac)는 POJO 인스턴스 또는 빈에 액세스할 수 있는 역할을 함
- 실제로 POJO는 대부분 DB나 유저 입력을 활용해 인스턴스로 만듬
- 기본적으로 스프링은 @Configuration, @Component, @Bean, @Repository, @Service, @Controller가 달린 클래스들을 모두 감지
- 이 때, 하나 이상의 포함/제외 필터를 사용해 스캐닝 과정을 커스터마이징 할 수 있음
- 특정 애노테이션을 붙인 POJO를 스프링 애플리케이션 컨텍스트에서 빼거나 넣거나 하는 것
- 여러 곳에 분산된 POJO 참조문제 해결하는 법은 두가지가 있음
- Application 규모가 커질수록 모든 POJO 설정을 하나의 자바 구성 클래스에 담아두기 어렵기 때문에 나누어 관리하는 것
- ex) AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(~.class,~.class);
- @Import를 사용하는 것
- ex) @Import(~.class)
- POJO가 여럿일 때, @Autowired는 대상이 모호해짐 Why? 호환되는 타입의 빈을 모두 찾기 때문. 따라서 해당 프로퍼티가 열거형이 아니라면 에러가 날 수 있음
- 이러한 문제를 @Primary(해당 빈에 우선권을 줌), @Qualifier("")(빈의 이름을 명시할 수 있음) 두 가지 애노테이션을 사용
- @Resource -> 기능 상 @Autowired와 @Qualifier를 합친것과 같으므로 대상이 명확
- @Component 같은 애노테이션을 POJO 인스턴스에 붙이는 건 빈 생성에 관한 템플릿을 정의하는 것이지, 인스턴스 정의가 아님
- @Scope는 빈 스코프를 지정하는 애노테이션
- 스프링은 IoC 컨테이너에 선언한 빈마다 정확히 인스턴스 하나를 생성하고, 이렇게 만들어진 인스턴스는 전체 컨테이너 스코프에 공유됨
- 이것이 바로 모든 빈의 기본 스코프인 Singleton
- singleton -> IoC 컨테이너 당 빈 인스턴스 하나를 생성
- prototype -> 요청할 떄마다 빈 인스턴스를 새로 만듬
- request -> HTTP 요청 당 하나의 빈 인스턴스를 생성, 웹 애플리케이션 컨텍스트에만 해당
- session -> HTTP 세션 당 빈 인스턴스 하나를 생성, 웹 애플리케이션 컨텍스트에만 해당
- globalSession -> 전역 HTTP 세션 당 빈 인스턴스 하나를 생성, 포털 애플리케이션 컨텍스트에만 해당
- 스프링이 제공하는 @PropertySource를 이용하면 빈 프로퍼티 구성용 .properties 파일(키-값)을 읽어들일 수 있음
- @PostConstruct는 스프링에게 빈을 생성한 후 이 메서드를 자동 실행하라고 지시
- @PostConstruct -> 빈 생성 이후에 이 메서드 실행
- @PreDestroy -> 빈 폐기 이전에 이 메서드 실행
- @Lazy -> 나중에 초기화하는 개념
- 기본적으로 스프링은 모든 POJO를 조급하게 초기화(eager), 다시 말해 애플리케이션 시동과 동시에 POJO를 초기화함
- 하지만 환경에 따라 빈을 처음으로 요청하기 전까지 초기화 과정을 미루는 것이 더 좋은 경우가 있음
- 느긋하게 초기화하면, 시동 시점에 리소스를 집중 소모하지 않아도 되므로 전체 시스템 리소스를 절약할 수 있음
- @Bean 메서드는 정적 팩토리를 호출하거나 인스턴스 팩토리 메서드를 호출해서 POJO를 생성할 수 있음
- Aspect를 정의하려면 우선 자바 클래스에 @Aspect를 붙이고 메서드별로 적절한 애노테이션을 붙여 어드바이스로 만듬
- 어드바이스 애노테이션은 @Before, @After, @AfterReturning, @AfterThrowing, @Around 중 하나를 사용 가능
- IoC 컨테이너에서 애스팩트 애노테이션 기능을 활성화하려면 구성 클래스 중 하나에 @EnableAspectJAutoProxy를 붙임
- 기본적으로 스프링은 인터페이스 기반의 JDK 동적 프록시(다이나믹 프록시)를 생성하여 AOP를 적용함
- @EnableAspectJAutoProxy에서 proxyTargetClass 속성을 true로 설정하면 동적 프록시 대신 CGLIB을 사용
- 애스팩트는 여러 타입과 객체에 공통 관심사(예: 로깅, 트랜잭션 관리)를 모듈화한 자바 클래스로, @Aspect를 붙여 표시
- AOP에서 말하는 애스팩트란, 어디에서(포인트컷) 무엇을 할것인지(어드바이스)를 합쳐놓은 개념
- 어드바이스는 @Advice를 붙인 단순 자바 메서드로, AspectJ는 @Before, @After, @AfterReturning, @AfterThrowing, @Around 다섯 개 어드바이스 애노테이션 지원
- 포인트컷은 어드바이스에 적용할 타입 및 객체를 찾는 표현식
- AOP는 간단히 말해서,(개인적인 생각 정리) 여러 작업들에 있어서 반복적으로 해야하는 작업인, 권한/인증/인가/로깅 등의 작업들을 각각 반복적인 코드를 사용하지 않고 재사용할 수 있게 하는 관점의 코드라고 생각하면 됨
- 예시로, 작업들의 테스크가 가로로 쭉 이어져나가있다고 한다면, AOP는 종단으로 가로지르는 것으로, 하나의 코드로 여러 작업들에 대해서 작업을 진행할 수 있음
- 스프링 AOP가 지원하는 조인포인트 대상은 IoC 컨테이너 안에 선언된 빈에 국한됨
- 이 스코프를 벗어나 포인트컷 표현식을 쓰면 IllegalArgumentException 예외 발생
- 어떤 공통 로직을 공유하는 클래스가 여러 개 있을 경우, 보통 OOP에서는 같은 베이스 클래스(상속의 형태로 하위 클래스를 파생시킬 의도로 만든 최상위 클래스)를 상속하거나 같은 인터페이스를 구현하는 형태로 애플리케이션 개발
- AOP 관점에서는 충분히 모듈화 가능한 공통 관심사인데, 자바는 언어 구조상 클래스를 오직 한 개만 상속할 수 있기 때문에 동시에 여러 구현 클래스로부터 기능을 물려받아 쓰는 일은 불가능함
- 이를 해결하기 위해 인트로덕션을 사용
- 이는 AOP 어드바이스의 특별한 타입으로, 객체가 어떤 인터페이스의 구현 클래스를 공급받아 동적으로 인터페이스를 구현하는 기술
- 그리고 여러 구현 클래스를 지닌 여러 인터페이스를 동시에 인트로듀스(끌어들일) 할 수 있어서 사실상 다중상속도 가능
- 